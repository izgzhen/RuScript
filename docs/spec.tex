\documentclass[]{article}
\usepackage{lmodern}
\usepackage{mathtools}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript

% XeLaTeX
\usepackage{mathspec}
\usepackage{xltxtra,xunicode}

\defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
% xetex
\usepackage[setpagesize=false, % page size defined by xetex
            unicode=false, % unicode breaks when used with xetex
            xetex]{hyperref}

\hypersetup{breaklinks=true,
            pdfauthor={Zhen Zhang},
            pdftitle={Spec of Ruscript},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=black,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{10}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}

\setcounter{tocdepth}{2}


\title{Specification of RuScript}
\date{\today \\ Draft v2.0}
\author{Zhen Zhang \\ Find me on GitHub \href{https://github.com/izgzhen}{@izgzhen}}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Abstract Computation Model}\label{abstract-computation-model}

\subsection{Representation}\label{representation}

The source code is an array of instructions coded in binary. The running
program is a stack of frames and object pool, in which every frame is
composed of:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Local Stack (abbr. \emph{stack})
\item
  Local registers (abbr. \emph{locals})
\item
  Global registers (abbr. \emph{globals})
\item
  Frame code block (abbr. \emph{code})
\end{enumerate}

\emph{Object pool} is a managed heap. All living objects will live in
heap, and accessible by \texttt{Gc} type, or \emph{pointer}; when some
object becomes inaccessible, it will be garbage collected.

The stack and registers are all container of pointers. The stack is
where most computations operate on. The registers are meant for fast access of objects.

Stack can only be pushed or popped. It is assumed to
be unlimited in size. And if stack underflowed, program will
panic. Registers is an array of finite and fixed length. When the index is
invalid, program will panic.

\subsection{Code Structure}\label{code-structure}

\paragraph{The grammar}\label{the-grammar}

\begin{verbatim}
<toplevel>      := [<statement>;]

<assignment>    := <identifier> = <expr>

<expr>          := <term> + <term>
                 | <term>

<term>          := <int>
                 | <ident>
                 | <string>
                 | new <ident>
                 | <ident>.<ident>([<expr>,])

<statement>     := <assignment>
                 | <classDecl>
                 | print <expr>
                 | return <expr>

<classDecl>     := class <ident> { [ <attrDecl> | <methodDecl> ] }

<attrDecl>      := <ident>

<methodDecl>    := fn <ident>([<ident>,]) {
                            [<globalDecl>]
                            [<statments>]
                        }

<globalDecl>    := global <ident>
\end{verbatim}

Note \#1: When we say ``\emph{A is defined in scope X}'',

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  If A is a variable, we mean that there exists an assignment
  \texttt{A = \textless{}expr\textgreater{}} in X
\item
  If A is a method, we mean that A is defined in some class as a method
\item
  If A is a class, we mean that A is defined in some top-level
  statement
\end{itemize}

Note \#2: By ``\emph{variable}'', we mean named primitive objects or
instances

\subsection{Scope and Scoping}\label{scope-and-scoping}

Kinds of scope:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Global (or top-level) scope: contains defined variables, classes
\item
  Local (or method) scope: contains arguments, declared globals,
  variable defined in method source
\item
  Class scope: contains only and always \texttt{self}. \texttt{self} can be used
  to refer the being-defined class's attributes and methods with common accessor
  pattern.
\end{itemize}

Scoping rules:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Globals: Visible to top-level code after it is defined on top-level;
  Visible to method code after it is defined on top-level and declared
  as \texttt{global} at the beginning of method.
\item
  Locals: Only visible to method's code
\item
  Classes: Visible after defined
\end{itemize}

Note: The principle is to give warnings of name collision, and
give errors when scoping found nothing. If collision happens, the scoping priorities
are ``local \textgreater{} class \textgreater{} global''.

\subsection{Object System}\label{object-system}

Current object system is rather simple. It has the following features:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Everything is an \emph{object}, and every computation is \emph{message
  passing}
\item
  \emph{Class} can be instantiated to \emph{instance}
\item
  \emph{Accessor} pattern, which we use to read \emph{attributes} and
  invoke \emph{method}
\end{itemize}

The \texttt{\_Object} contains all kinds of object defined:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Primitive Objects

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    \texttt{Int\_ty}: 32-bit signed integer
  \item
    \texttt{Array\_ty}: Integer-indexed growable array of objects
  \item
    \texttt{String\_ty}: Immutable string
  \end{itemize}
\item
  \texttt{Frame\_ty}: Representing a frame
\item
  \texttt{Instance\_ty}: Represent a general object as a instance of
  class
\item
  \texttt{Class\_ty}: Represent class definition
\end{itemize}

Every object must fulfill \texttt{Object} trait:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trait} \NormalTok{Object \{}
    \KeywordTok{fn} \NormalTok{call(&}\KeywordTok{self}\NormalTok{,}
            \NormalTok{name: &}\KeywordTok{str}\NormalTok{,}
            \NormalTok{args: Vec<Gc<_Object>>,}
            \NormalTok{env: &Gc<Env>,}
            \NormalTok{globals: &}\KeywordTok{mut} \NormalTok{Vec<Gc<_Object>>) -> Gc<_Object>;}

    \KeywordTok{fn} \NormalTok{tyof(&}\KeywordTok{self}\NormalTok{) -> &}\KeywordTok{str}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Stack System}\label{stack-system}

Stack system is the implementation of the abstract computation model
described above. It is an interpreter for variable-length instruction
(i.e. \emph{SCode}).

In the following text, all instructions and their operational semantics
will be given in a formal way.

Note: Currently, the \texttt{SCode} is a mixture of classical data
segment and text segment. All data will be carried in the instruction.
But since actual binary layout has little to do with semantics, I will
try to avoid referring to actual binary layout in formalization, but
using $INST(D1, D2)$ to claim the relationship between operator and
operands.

\subsection{All instructions}\label{all-instructions}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{PUSHG(Integer)}
\item
  \texttt{PUSHL(Integer)}
\item
  \texttt{PUSHA(Integer)}
\item
  \texttt{POPG(Integer)}
\item
  \texttt{POPL(Integer)}
\item
  \texttt{POPA(Integer)}
\item
  \texttt{ADD}
\item
  \texttt{CALL(Integer, String, Integer)}
\item
  \texttt{RET}
\item
  \texttt{NEW(Integer)}
\item
  \texttt{PUSH\_INT(Integer)}
\item
  \texttt{PUSH\_STR(String)}
\item
  \texttt{FRMEND}
\item
  \texttt{CLASS(Integer, Integer)}
\item
  \texttt{PRINT}
\end{itemize}

Naming conventions: \texttt{G} means global, \texttt{L} means local,
\texttt{A} means attribute, \texttt{PUSHX(i)} means push
\texttt{i}-indexed element of \texttt{X} on top of stack,
\texttt{POPX(i)} means pop top of stack to \texttt{i}-indexed position
of \texttt{X}.

\subsection{Formal Computation Model}\label{formal-computation-model}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Environment: $E$, tuple $(L, G, S, C)$
\item
  Locals: $L$, mutable finite array
\item
  Globals: $G$, mutable finite array
\item
  Stack: $S$, mutable infinite stack
\item
  Classes: $C$, immutable array of class definitions
\item
  Code block: $\Sigma$, immutable array of instructions
\item
  Instruction Space: $I$, set of defined instructions
\item
  Frame: $F$, tuple $(\Sigma, E)$
\item
  Object: $\omega$, any entity satisfying \texttt{Object} trait
\item
  Heap: $H$, set of managed objects
\item
  Pointer: $\psi$, a managed reference to some $\omega \in H$
\item
  Program: $P$, tuple of $(C, \Sigma)$
\item
  Identifier Space: $\eta$
\item
  Expression: $e$
\end{itemize}

Note: For commonly used collection type, set or array will be notated as $[]$, tuple will be notated as $()$

A complete computation is defined as a function
$f_{comp}: (P, World) \rightarrow World'$, in which the $World'$ is
temporarily defined as $(B, H)$, in which $B$ is standard output buffer.

Note: To make formula cleaner, we might use monad-like notation to
describe side-effect, i.e. $f: A \rightarrow EnvM(B)$ is equivalent to
$f: (A, Env) \rightarrow (B, Env')$

First, $P$ will be loaded into a root frame:
$f_{load}: P \rightarrow F_0$.

Then, we will define an undecidable computing process
$f_{run}: F_i \rightarrow WorldM(\omega_{i})$

If $F$ is the root frame, then $\omega_0$ will be discarded and program
terminates, if not, $\omega_i$ will be \emph{returned} to caller and the
current frame will be popped out.

\emph{Method invoking} is a way to create a frame, run it and turn the
returned value into a $term$. It is a way to abstract computation. It is
actually a special case of object \texttt{call} trait.
$f_{invoke}: (\omega, m, [e]) \rightarrow WorldM(F)$. So by invoking, we can get
value of call expression
$f_{eval}{(\omega.m([e])} = (f_{invoke}(\omega, m, [e]) \gg = f_{run})$

Thus, we can abstract the computation as a recursive process of
``invoking, frame interpretation, finally returning value''. Formally, we will present the ``computation progress'' as a stack
of frames: $F_0 \diamond F_1 \diamond F_2 ... \diamond F_i$, where $F_i$
is the current frame.s All $F_0 ... F_{n - 1}$ is ``suspended
computation''.

In summary, by a single step interpretation, we will have

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Frame computation:
  $F_0 \diamond F_1 \diamond F_2 ... \diamond F_i \rightarrow F_0 \diamond F_1 \diamond F_2 ... \diamond F_i'$
\item
  Frame suspension and creation:
  $F_0 \diamond F_1 \diamond F_2 ... \diamond F_i \rightarrow F_0 \diamond F_1 \diamond F_2 ... \diamond F_i \diamond F_{i + 1}$
\item
  Frame continuation and completion:
  $F_0 \diamond F_1 \diamond F_2 ... \diamond F_i \rightarrow F_0 \diamond F_1 \diamond F_2 ... \diamond F_{i - 1}$
\end{itemize}

Note that although we don't explicitly emphasize every time,
but all computational transformation is accompanied with some side-effects,
which is formalized with $WorldM$.

In the following formal semantics, if it is simply a frame computation,
then we will conceal the frame structure; But if not, we will take
everything into the formal presentation.

\subsection{Formal Semantics}\label{formal-semantics}

\paragraph{\texttt{PUSHG(Integer)}}\label{pushginteger}

\begin{gather*}
  \langle (L, G, C, S), PUSHG(i)\rangle \Rightarrow WorldM (L, G, C, G[i] \rhd S )\\
  WorldM \leadsto H[G[i]] \uparrow
\end{gather*}

\paragraph{\texttt{PUSHL(Integer)}}\label{pushlinteger}

\begin{gather*}
  \langle (L, G, C, S), PUSHL(i)\rangle \Rightarrow WorldM (L, G, C, L[i] \rhd S )\\
  WorldM \leadsto H[L[i]] \uparrow
\end{gather*}

\paragraph{\texttt{PUSHA(Integer)}}\label{pushainteger}

\begin{gather*}
  \langle (L, G, C, S@(\omega \rhd S')), PUSHA(i)\rangle \Rightarrow WorldM (L, G, C, \omega.attrs[i] \rhd S )\\
  WorldM \leadsto H[\omega] \uparrow
\end{gather*}

\paragraph{\texttt{POPG(Integer)}}\label{popginteger}

\begin{gather*}
  \langle (L, G, C, \omega \rhd S'), POPG(i)\rangle \Rightarrow WorldM (L, subst(G, i, \omega), C, S' )\\
  WorldM \leadsto H[G[i]] \downarrow
\end{gather*}

\paragraph{\texttt{POPL(Integer)}}\label{poplinteger}

\begin{gather*}
  \langle (L, G, C, \omega \rhd S'), POPL(i)\rangle \Rightarrow WorldM (subst(L, i, \omega), G, C, S' )\\
  WorldM \leadsto H[L[i]] \downarrow
\end{gather*}

\paragraph{\texttt{POPA(Integer)}}\label{popainteger}

\begin{gather*}
  \langle (L, G, C, \omega_1 \rhd \omega_2 \rhd S'), POPA(i)\rangle \Rightarrow WorldM (L, G, C, subst(\omega_2, i, \omega_1) \rhd S' )\\
  WorldM \leadsto H[\omega_2.attrs[i]] \downarrow
\end{gather*}

\paragraph{\texttt{ADD}}\label{add}

\begin{gather*}
  \langle (L, G, C, \omega_1 \rhd \omega_2 \rhd S'), ADD\rangle, \omega_3 \sim \omega_1 + \omega_2 \Rightarrow WorldM (L, G, C, \omega_3 \rhd S')\\
  WorldM \leadsto H[\omega_1] \downarrow, H[\omega_2] \downarrow, H.new(\omega_3)
\end{gather*}

\paragraph{\texttt{CALL(Integer, String, Integer)}}\label{callinteger-string-integer}

\begin{gather*}
  \begin{rcases}
    \langle (L, G, C, \omega_1 \rhd \omega_2 \rhd ... \omega_n \rhd S'), CALL(i, m, n)\rangle\\
    \omega \leftarrow scope(L + G, i), \omega.m(\omega_1, ..., \omega_n) \sim \omega'
  \end{rcases}
  \quad
    \Rightarrow WorldM (L, G, C, \omega' \rhd S' )\\
  WorldM \leadsto \forall i \in 1...n, H[\omega_i] \downarrow, H.new(\omega')
\end{gather*}

\paragraph{\texttt{RET}}\label{ret}

\begin{gather*}
  F_0@\langle (L, G, C, \omega \rhd S'), RET\rangle \Rightarrow terminate \\
  F_0 \diamond ... \diamond F_{i - 1}@(Susp: \omega \rightarrow \langle E, i \rangle)\diamond F_i@\langle (L, G, C, \omega \rhd S'), RET\rangle \Rightarrow F_0 \diamond ... \diamond F_{i-1}@ \langle E, i \rangle
\end{gather*}

\paragraph{\texttt{NEW(Integer)}}\label{newinteger}

\begin{gather*}
  \langle (L, G, C, S), NEW(i)\rangle, \omega \leftarrow C[i].new() \Rightarrow WorldM (L, G, C, \omega \rhd S)\\
  WorldM \leadsto H.new(\omega)
\end{gather*}

\paragraph{\texttt{PUSH\_INT(Integer)}}\label{pushux5fintinteger}

\begin{gather*}
  \langle (L, G, C, S), PUSH\_INT(i)\rangle, \omega \leftarrow Int.new(i) \Rightarrow WorldM (L, G, C, \omega \rhd S)\\
  WorldM \leadsto H.new(\omega)
\end{gather*}

\paragraph{\texttt{PUSH\_STR(String)}}\label{pushux5fstrstring}

\begin{gather*}
  \langle (L, G, C, S), PUSH\_INT(s)\rangle, \omega \leftarrow String.new(s) \Rightarrow WorldM (L, G, C, \omega \rhd S)\\
  WorldM \leadsto H.new(\omega)
\end{gather*}

\paragraph{\texttt{FRMEND}}\label{frmend}

This is a pseudo-instruction.

\paragraph{\texttt{CLASS(Integer, Integer)}}\label{classinteger-integer}

This is a pseudo-instruction.

\paragraph{\texttt{PRINT}}\label{print}

\begin{gather*}
  \langle (L, G, C, \omega \rhd S), PRINT\rangle \Rightarrow WorldM (L, G, C, \omega \rhd S) \\
  WorldM \leadsto B.print(\omega)
\end{gather*}

\section{Exception handling and correctness
protocol}\label{exception-handling-and-correctness-protocol}

\subsection{Exception Handling}\label{exception-handling}

Currently, RuScript doesn't have error handling capacity, if any
undefined behaviour happens, the interpreter will simply panic.

However, a protocol of correctness should exist. First, the language
should have only high-level exceptions, like ``divide by zero'', ``no
such method'', ``out of index'' and so on, but never low-level errors caused by
virtual machine itself, like stack underflow, register indexing error,
invalid instruction et cetera. To be able to include the first category of
exceptions in the specification, we should make sure that
they can't cause interpreter panic at runtime. The defined exceptions should
print debugging information and exit normally. Such a protocol should be implemented
by compiler.

\begin{quote}
Correctness Protocol: \emph{As long as runtime system is enforcing the
formal model, any compiled code should not cause panic to runtime
system} 
\end{quote}


\subsection{Correctness Protocol Implementation}

Essentially, this implementation is a \emph{correctness proof of an existing compiler}.
So, here we will only give some examples of implementation.

The hand-written proofs can be lengthy, imprecise and unreadable, so
maybe it is possible to construct a model in Coq.

\paragraph{Example}\label{example}

Prove that the following excerpt can generate correct code for expression
$t_1 + t_2$, assuming that \texttt{pushTerm} can emit a segment of code,
which when executed, can correctly leave the computed value on top of stack.

\begin{verbatim}
pushExpr (Plus tm1 tm2) = do
    pushTerm tm1
    pushTerm tm2
    emit SAdd
\end{verbatim}

Proof:

According to assumption, let \texttt{pushTerm} be such a function
$f_{term}: Term \rightarrow CompilerM(\Sigma)$, in which $Term$ is lexical
representation of a term, and $CompilerM$ is the monad analogy of a
compiler. And for any $t \in Term$, if $t$ is computable under
environment $E$, then $\langle E, \Sigma \rangle \Rightarrow E'$, in which top of stack
of $E'$ is value-equivalent of $Term$.

So, let $$\Sigma_1 \leftarrow f_{term}(t_1), \Sigma_2 \leftarrow f_{term}(t_2)$$
then $$ \Sigma_1 + \Sigma_2 + [SAdd] \leftarrow f_{expr}(Plus(t1, t2))$$
since
\begin{gather*}
  \langle (L, G, C, S), \Sigma_1\rangle, \omega_1 \sim t_1 \Rightarrow (L, G, C, \omega_1 \rhd S) \\
  \langle (L, G, C, S), \Sigma_2\rangle, \omega_2 \sim t_2 \Rightarrow (L, G, C, \omega_2 \rhd S)
\end{gather*}
so $$\langle (L, G, C, S), \Sigma_1 + \Sigma_2\rangle, \omega_1 \sim t_1, \omega_2 \sim t_2 \Rightarrow (L, G, C, \omega_2 \rhd \omega_1 \rhd S)$$
then $$\langle (L, G, C, S), \Sigma_1 + \Sigma_2 + SAdd\rangle, \omega_3 \sim (t_1 + t_2) \Rightarrow (L, G, C, \omega_3 \rhd S)$$
which conforms to the spec.

\section{High-Level Language Construct}\label{high-level-language-construct}

\subsection{Symbols}\label{symbols}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Statement: $S$
\item
  Expression: $E$
\item
  Self: $self$
\item
  Identifier (not a keyword): $Id$
\item
  Assignment: $x \mapsto e$, $x \in V, e \in E$
\item
  Term: $T$
\item
  (real) parameter list: $\forall e_i \in E, (e_0, e_1, ...)$
\item
  (formal) arguments list: $\forall x_i \in Id, (x_0, x_1, ...)$
\item
  Class: $C$
\item
  Method invoking:
  $\forall c \in C, e_i \in E, f \in Id, c.f(e_0, e_1, ...) \in T$
\item
  Attribute accessing: $\forall c \in C, \alpha \in Id, c.\alpha \in T$
\item
  Print: $\forall e \in E, print(e) \in S$
\item
  Return: $\forall e \in E, return(e) \in S$
\item
  Plus: $\forall t_0, t_1 \in T, t_0 + t_1 \in E$
\item
  Declared \texttt{global} names: $x_g \in X_g$
\item
  Locally defined names: $x_L \in X_L$
\item
  Globally defined names: $x_G \in X_G$
\item
  Integer $i \in \mathbb Z$
\item
  String $s \in \mathbb S$
\item
  Construction $\forall c \in C, new(c) \in T$
\end{itemize}

\subsection{Semantics}\label{semantics}

\paragraph{Assigment}\label{assigment}

\[\frac{x \in X_g, SC_G(x) = i, \omega \sim e}
        {F_{>0}@\langle (L, G, C, S), Compile (x \mapsto e) \rangle \Rightarrow (L, G[i \mapsto \omega]), C, S)}\]

\[\frac{x \in X_L, SC_L(x) = i, \omega \sim e}
        {F_{>0}@\langle (L, G, C, S), Compile (x \mapsto e) \rangle \Rightarrow (L[i \mapsto \omega], G, C, S)}\]

\[\frac{x \in X_G, SC_G(x) = i, \omega \sim e}
        {F_0@\langle (\emptyset, G, C, S), Compile (x \mapsto e) \rangle \Rightarrow (\emptyset, G[i \mapsto \omega], C, S)}\]

\paragraph{Expression \& Term
evaluation}\label{expression-term-evaluation}

\[\frac{t_0 \sim \omega_0, t_1 \sim \omega_1, e = t_0 + t_1}
        {e \sim \omega_0 + \omega_1}\]

\[\frac{\langle(L, G, C, S), Compile(push(t)) \rangle \Rightarrow (L, G, C, \omega \rhd S)}
        {t \sim \omega}\]

\[\frac{x \in X_{g|L|G}, SC_{G|L}(x) = i, G|L[i] = \omega}{x \sim_{G|L} \omega}\]

\[\frac{prim \in \mathbb{Z|S}, prim \sim \omega}
        {\langle S, Compile(push(prim)) \rangle \Rightarrow (\omega \rhd S)}\]

\[\frac{c \in C, \omega = New(c)}
        {\langle S, Compile(push(new(c))) \rangle \Rightarrow (\omega \rhd S)}\]

\[\frac{x \in Id, x \sim \omega}
        {\langle S, Compile(push(x)) \rangle \Rightarrow (\omega \rhd S)}\]

\[\frac{x \sim \omega_x, ClassOf(\omega_x) = c,  e_i \sim \omega_i, f_{run}(c.f, [\omega_i]) \sim \omega}
        {\langle S, Compile(push(x.f([e_i]))) \rangle \Rightarrow (\omega \rhd S)}\]

\[\frac{x \sim \omega_x, ClassOf(\omega_x) = c, i = FindIndex(\alpha, c.attrs), \omega_x.attrs[i] = \omega }
        {\langle (C, S), Compile(push(x.\alpha)) \rangle \Rightarrow (\omega \rhd S)}\]

\paragraph{Equivalence}\label{equivalence}

$L \Rightarrow L'$ can be \emph{equivalently} written as
$L \Rightarrow L$ iff.
$\forall x \in X_{L}, x \sim_L \omega, x \in X_{L'} \cap x \sim_{L'} \omega$.
Same for $G$. $S$ must be completely equivalent.

And to make notation less cluttered, when $L, S, C, G$ is not referenced
and equivalent under interpretation, we can neglect them in the
expression.

\paragraph{Misc}\label{misc}

\[\frac{cb_1, cb_2 \in [S], \langle E, Compile(cb_1) \rangle \Rightarrow E', \langle E', Compile(s_2) \rangle \Rightarrow E''}
       {\langle E, Compile(cb_1 + cb_2) \rangle \Rightarrow E''}\]

\begin{gather*} F_0 \diamond ... \diamond F_i @\langle(L_i, G, C, S_i) , Susp \rangle \diamond \langle ([\omega_0, \omega_1, ..., void, ...], G, C, empty\_stack) , f \rangle \\ \Downarrow \\ F_0 \diamond ... \diamond F_i \diamond \langle (L, G, C, \omega \rhd S) RET \rangle \\ \line(1,0){250} \\f_{run}(f, [\omega_i]) \sim \omega
\end{gather*}


XXX: We should move ``G'' to a really global place \ldots{} coming up
with good notation is hard for me.


\end{document}
